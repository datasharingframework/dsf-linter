package dev.dsf.linter.service;

import dev.dsf.linter.bpmn.BpmnLinter;
import dev.dsf.linter.logger.Logger;
import dev.dsf.linter.output.LinterSeverity;
import dev.dsf.linter.output.LintingType;
import dev.dsf.linter.output.item.AbstractLintItem;
import dev.dsf.linter.output.item.BpmnElementLintItem;
import dev.dsf.linter.output.item.PluginLintItem;
import dev.dsf.linter.util.linting.LintingOutput;
import dev.dsf.linter.util.resource.ResourceResolutionResult;

import java.io.File;

/**
 * Service for linting BPMN (Business Process Model and Notation) files in DSF process plugins.
 * <p>
 * This service extends {@link AbstractResourceLintingService} to provide BPMN-specific linting
 * functionality while inheriting common resource validation operations. It implements the
 * Template Method pattern, where the base class defines the linting algorithm structure and
 * this class provides BPMN-specific implementations of the abstract methods.
 * </p>
 *
 * <h3>Responsibilities:</h3>
 * <ul>
 *   <li>Linting individual BPMN files for syntax, structure, and business rule violations</li>
 *   <li>Validating BPMN file references in plugin definitions</li>
 *   <li>Checking resource location (inside/outside expected root, in dependencies)</li>
 *   <li>Creating appropriate lint items for different error scenarios</li>
 * </ul>
 *
 * <h3>Linting Process:</h3>
 * <p>
 * The service performs the following checks for each BPMN file:
 * </p>
 * <ol>
 *   <li><strong>File Existence:</strong> Verifies that referenced BPMN files exist</li>
 *   <li><strong>Location Validation:</strong> Checks if files are in expected resource root</li>
 *   <li><strong>Content Linting:</strong> Validates BPMN syntax, element names, field injections,
 *       FHIR resource references, and business logic constraints via {@link BpmnLinter}</li>
 *   <li><strong>Dependency Tracking:</strong> Identifies BPMN files found in dependency JARs</li>
 * </ol>
 *
 * <h3>Lint Item Types:</h3>
 * <p>
 * This service creates instances of {@link PluginLintItem} and {@link BpmnElementLintItem}
 * with different {@link LintingType} values to report validation results:
 * </p>
 * <ul>
 *   <li>{@link LintingType#PLUGIN_DEFINITION_BPMN_FILE_NOT_FOUND} - When a referenced
 *       BPMN file cannot be found (created as {@link PluginLintItem} with {@link LinterSeverity#ERROR})</li>
 *   <li>{@link LintingType#PLUGIN_DEFINITION_BPMN_FILE_OUTSIDE_ROOT} - When a BPMN file
 *       is found outside the expected resource root (created as {@link PluginLintItem} with {@link LinterSeverity#WARN})</li>
 *   <li>{@link LintingType#PLUGIN_DEFINITION_UNPARSABLE_BPMN_RESOURCE} - When a BPMN file
 *       cannot be parsed (handled automatically by the base class)</li>
 *   <li>Success items created via {@link BpmnElementLintItem#success(String, File, String, String)}
 *       when a BPMN file is successfully validated at the resource level</li>
 *   <li>Success items created via {@link PluginLintItem#success(File, String, String)}
 *       when a BPMN file is successfully parsed and linted at the plugin level</li>
 * </ul>
 * <p>
 * Additional lint items are generated by the delegated {@link BpmnLinter}, which reports
 * detailed BPMN element-level issues through {@link BpmnElementLintItem} instances.
 * </p>
 *
 * <h3>Usage Example:</h3>
 * <pre>{@code
 * Logger logger = new ConsoleLogger();
 * BpmnLintingService service = new BpmnLintingService(logger);
 *
 * List<File> bpmnFiles = Arrays.asList(
 *     new File("bpe/update-allow-list.bpmn"),
 *     new File("bpe/download-allow-list.bpmn")
 * );
 * List<String> missingRefs = Collections.emptyList();
 * Map<String, ResourceResolutionResult> outsideRoot = new HashMap<>();
 * Map<String, ResourceResolutionResult> fromDependencies = new HashMap<>();
 * File pluginResourceRoot = new File("bpe");
 *
 * LintingResult result = service.lint(
 *     "my-plugin",
 *     bpmnFiles,
 *     missingRefs,
 *     outsideRoot,
 *     fromDependencies,
 *     pluginResourceRoot
 * );
 * }</pre>
 *
 * <h3>Integration:</h3>
 * <p>
 * This service is typically used by the plugin linting orchestrator to validate
 * BPMN resources for each discovered DSF process plugin. The actual BPMN content validation
 * is delegated to {@link BpmnLinter}, which performs detailed checks on BPMN elements,
 * events, tasks, gateways, flows, and their relationships to FHIR resources.
 * </p>
 *
 * <h3>Thread Safety:</h3>
 * <p>
 * This class is not thread-safe due to the internal {@link BpmnLinter} instance. Each thread
 * should use its own instance of {@code BpmnLintingService}.
 * </p>
 *
 * @see AbstractResourceLintingService
 * @see BpmnLinter
 * @see PluginLintItem
 * @see BpmnElementLintItem
 * @see LintingType
 * @see LinterSeverity
 * @see ResourceResolutionResult
 * @see LintingOutput
 * @since 1.1.0
 */
public class BpmnLintingService extends AbstractResourceLintingService {

    private final BpmnLinter bpmnLinter;

    public BpmnLintingService(Logger logger) {
        super(logger);
        this.bpmnLinter = new BpmnLinter();
    }

    @Override
    protected String getResourceTypeName() {
        return "BPMN";
    }

    @Override
    protected LintingOutput lintSingleFile(String pluginName, File resourceFile) {
        return bpmnLinter.lintBpmnFile(resourceFile.toPath());
    }

    @Override
    protected AbstractLintItem createMissingReferenceLintItem(String pluginName, String missingRef) {
        return new PluginLintItem(
                LinterSeverity.ERROR,
                LintingType.PLUGIN_DEFINITION_BPMN_FILE_NOT_FOUND,
                new File(missingRef),
                pluginName,
                "Referenced BPMN file not found"
        );
    }

    @Override
    protected AbstractLintItem createOutsideRootLintItem(
            String pluginName,
            String reference,
            ResourceResolutionResult result) {

        return new PluginLintItem(
                LinterSeverity.WARN,
                LintingType.PLUGIN_DEFINITION_BPMN_FILE_OUTSIDE_ROOT,
                result.file().orElseThrow(),
                pluginName,
                String.format("BPMN file '%s' found outside expected root '%s' at '%s'",
                        reference, result.expectedRoot(), result.actualLocation())
        );
    }

    @Override
    protected AbstractLintItem createResourceSuccessItem(
            String pluginName,
            File resourceFile,
            LintingOutput output) {

        String processId = extractProcessId(output);
        return BpmnElementLintItem.success(processId, resourceFile, processId,
                "Referenced BPMN file found and is readable.");
    }

    @Override
    protected AbstractLintItem createPluginSuccessItem(String pluginName, File resourceFile) {
        return PluginLintItem.success(resourceFile, pluginName,
                String.format("BPMN file '%s' successfully parsed and linted for plugin '%s'",
                        resourceFile.getName(), pluginName));
    }

    @Override
    protected boolean isUnparsableItem(AbstractLintItem item) {
        return item instanceof PluginLintItem pi &&
               pi.getType() == LintingType.PLUGIN_DEFINITION_UNPARSABLE_BPMN_RESOURCE;
    }

    private String extractProcessId(LintingOutput output) {
        String processId = output.getProcessId();
        return processId.isBlank() ? "[unknown_process]" : processId;
    }
}
